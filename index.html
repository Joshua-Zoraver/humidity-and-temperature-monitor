<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Greenhouse Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background: #f0f0f0; }
    h1 { color: green; }
    .card {
      border: 1px solid #ccc; padding: 20px; width: 90%; max-width: 300px;
      margin: 10px auto; border-radius: 8px; background: #fff; box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
    }
    .value { font-size: 2em; font-weight: bold; }
    .ok { color: green; }
    .alert { color: red; }

    .table-container {
      overflow-x: auto;
      margin-top: 20px;
      max-width: 100%;
    }
    table {
      width: 90%; max-width: 600px; margin: 20px auto; border-collapse: collapse; background: white;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
      min-width: 500px;
    }
    th, td {
      padding: 10px; border: 1px solid #ddd; text-align: center;
    }
    th {
      background-color: #e0e0e0;
    }

    @media (max-width: 600px) {
      table { font-size: 12px; }
      th, td { padding: 6px; }
      .card { padding: 10px; max-width: 95%; }
      .value { font-size: 1.5em; }
      h1, h2 { font-size: 1.2em; }
    }
    
    .chart-container {
      position: relative;
      height: 300px;
      width: 80vw;
      max-width: 800px;
      margin: 0 auto 20px auto;
    }
  </style>

  <!-- Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <h1>Greenhouse Dashboard</h1>

  <h2>Live Readings</h2>
  <div id="live-cards"></div>

  <div style="margin-bottom: 10px;">
    Show data for:
    <select id="timeWindow">
      <option value="600">Last 10 minutes</option>
      <option value="3600">Last 1 hour</option>
      <option value="86400">Last 24 hours</option>
    </select>
  </div>

  <h2>Temperature Over Time</h2>
  <div class="chart-container">
    <canvas id="tempChart"></canvas>
  </div>

  <h2>Humidity Over Time</h2>
  <div class="chart-container">
    <canvas id="humChart"></canvas>
  </div>

  <h2>Recent Sensor Data (Database)</h2>
  <div class="table-container">
    <table>
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>Sensor</th>
          <th>Value</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody id="history-table">
        <tr><td colspan="4">Loading...</td></tr>
      </tbody>
    </table>
  </div>

  <script>
function statusClass(status) {
  return status === "STABLE" ? "ok" : "alert";
}

function fmtNum(n, digits = 2) {
  if (n == null || Number.isNaN(Number(n))) return "--";
  return Number(n).toFixed(digits);
}

function secondsAgo(isoTs) {
  if (!isoTs) return null;
  const t = new Date(isoTs).getTime();
  if (Number.isNaN(t)) return null;
  return Math.floor((Date.now() - t) / 1000);
}

function isOnline(pi) {
  // Consider online if we have a reading within the last 30 seconds
  const ts = pi.temp_timestamp || pi.humidity_timestamp;
  const age = secondsAgo(ts);
  return age != null && age <= 30;
}

function renderLiveCards(pis) {
  const container = document.getElementById("live-cards");
  container.innerHTML = "";

  if (!Array.isArray(pis) || pis.length === 0) {
    container.innerHTML = `<div class="card"><p class="value">No live data</p></div>`;
    return;
  }

  // Sort with host first, then others
  pis.sort((a, b) => {
    if (a.pi_id === "host") return -1;
    if (b.pi_id === "host") return 1;
    return (a.pi_id || "").localeCompare(b.pi_id || "");
  });

  pis.forEach(pi => {
    const online = isOnline(pi);
    const lastTs = pi.temp_timestamp || pi.humidity_timestamp;
    const age = secondsAgo(lastTs);

    const tempStatus = pi.temp_status || "UNKNOWN";
    const humStatus  = pi.humidity_status || "UNKNOWN";

    const tempVal = pi.temperature;
    const humVal  = pi.humidity;

    const card = document.createElement("div");
    card.className = "card";

    card.innerHTML = `
      <h3>${pi.pi_id || "unknown"} ${online ? "[online]" : "[offline]️"}</h3>
      <p style="margin-top: -6px; color: #666;">
        ${age == null ? "Last update: --" : `Last update: ${age}s ago`}
      </p>

      <div style="margin-top: 10px;">
        <div>
          <strong>Temperature:</strong>
          <span class="value ${statusClass(tempStatus)}" style="font-size: 1.4em;">
            ${fmtNum(tempVal)} °C (${tempStatus})
          </span>
        </div>
        <div style="margin-top: 8px;">
          <strong>Humidity:</strong>
          <span class="value ${statusClass(humStatus)}" style="font-size: 1.4em;">
            ${fmtNum(humVal)} % (${humStatus})
          </span>
        </div>
      </div>
    `;

    container.appendChild(card);
  });
}

async function fetchLive() {
  try {
    const response = await fetch("/live");
    if (!response.ok) throw new Error(`API responded with status ${response.status}`);
    const data = await response.json();
    renderLiveCards(data);
  } catch (error) {
    const container = document.getElementById("live-cards");
    container.innerHTML = `
      <div class="card">
        <p class="value">Error: ${error.message}</p>
      </div>
    `;
    console.error("Error fetching live data:", error);
  }
}

    
    // Filtering time windows
    function filterByTimeWindow(history) {
      const seconds = parseInt(document.getElementById("timeWindow").value);
      const cutoff = Date.now() - seconds * 1000;

      return history.filter(row =>
        new Date(row.timestamp).getTime() >= cutoff
      );
    }

    // Chart.js instances
    let tempChart = null;
    let humChart = null;
    
    // Cache last history so UI can render instantly on dropdown change
    let latestHistory = [];

    // History table + charts
    async function fetchHistory() {
      try {
        const response = await fetch("/history");
        if (!response.ok) throw new Error(`API responded with status ${response.status}`);
        const history = await response.json();
        latestHistory = history;

        // Filter and update display
        updateDisplay();
      } catch (err) {
        document.getElementById("history-table").innerHTML =
          `<tr><td colspan="4">Error: ${err.message}</td></tr>`;
        console.error("Error fetching history:", err);
      }
    }

    // Function to update both table and charts
    function updateDisplay() {
      const filtered = filterByTimeWindow(latestHistory);
      
      // Update table
      const tableBody = document.getElementById("history-table");
      tableBody.innerHTML = "";
      
      if (filtered.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="4">No data for selected time window</td></tr>';
      } else {
        filtered.forEach(row => {
          const statusClass = row.status === "STABLE" ? "ok" : "alert";
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${row.timestamp}</td>
            <td>${row.sensor} (${row.pi_id})</td>
            <td>${row.value}</td>
            <td class="${statusClass}">${row.status}</td>
          `;
          tableBody.appendChild(tr);
        });
      }

      // Update charts
      updateCharts(filtered);
    }

    function updateCharts(history) {
  try {
    if (!Array.isArray(history)) {
      console.error("History from backend is not an array:", history);
      return;
    }

    console.log("Updating charts with", history.length, "data points");

    // Separate by sensor type
    const tempDataAll = history.filter(r => r.sensor === "temperature");
    const humDataAll  = history.filter(r => r.sensor === "humidity");

    // Downsample each sensor separately
    const tempData = downsample(tempDataAll, 200);
    const humData  = downsample(humDataAll, 200);

    // If no data for either sensor, clear charts
    if (tempData.length === 0 && humData.length === 0) {
      if (tempChart) {
        tempChart.data.labels = [];
        tempChart.data.datasets = [];
        tempChart.update();
      }
      if (humChart) {
        humChart.data.labels = [];
        humChart.data.datasets = [];
        humChart.update();
      }
      console.log("No data to display in charts");
      return;
    }

    // Pi IDs from whatever data we currently have
    const piIds = [...new Set(history.map(r => r.pi_id || "unknown"))];

    function buildChartData(sensorData) {
      if (sensorData.length === 0) {
        return { timestamps: [], dataByPi: {} };
      }

      const timestamps = [...new Set(sensorData.map(r => r.timestamp))].sort();
      const dataByPi = {};

      piIds.forEach(pi => {
        dataByPi[pi] = new Array(timestamps.length).fill(null);
      });

      sensorData.forEach(row => {
        const tIndex = timestamps.indexOf(row.timestamp);
        if (tIndex === -1) return;

        const pi = row.pi_id || "unknown";
        let val = row.value != null ? parseFloat(row.value) : null;

        // If this is humidity thats stored 0–1, convert to %
        if (row.sensor === "humidity" && val !== null && val <= 1) {
          val = val * 100;
        }

        dataByPi[pi][tIndex] = isNaN(val) ? null : val;
      });

      return { timestamps, dataByPi };
    }

    const tempChart_data = buildChartData(tempData);
    const humChart_data  = buildChartData(humData);

    const colors = ["red", "blue", "green", "orange", "purple", "brown", "magenta", "teal"];

    // Temperature chart
    const tempCanvas = document.getElementById("tempChart");
    const tempCtx = tempCanvas.getContext("2d");
    if (tempChart) tempChart.destroy();

    tempChart = new Chart(tempCtx, {
      type: "line",
      data: {
        labels: tempChart_data.timestamps,
        datasets: piIds.map((piId, idx) => ({
          label: `Temp - ${piId}`,
          data: tempChart_data.dataByPi[piId],
          borderColor: colors[idx % colors.length],
          tension: 0.2,
          spanGaps: true
        }))
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: "Time" },
            ticks: {
              maxRotation: 45,
              minRotation: 45,
              autoSkip: true,
              maxTicksLimit: 10,
              callback: function(value) {
                const timestamp = this.getLabelForValue(value);
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-NZ', {
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                });
              }
            }
          },
          y: { title: { display: true, text: "Temperature (°C)" } }
        },
        plugins: {
          legend: { position: "top" },
          tooltip: {
            callbacks: {
              title: (ctx) => {
                const date = new Date(ctx[0].label);
                return date.toLocaleString('en-NZ');
              },
              label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}°C`
            }
          }
        }
      }
    });

    // Humidity chart
    const humCanvas = document.getElementById("humChart");
    const humCtx = humCanvas.getContext("2d");
    if (humChart) humChart.destroy();

    humChart = new Chart(humCtx, {
      type: "line",
      data: {
        labels: humChart_data.timestamps,
        datasets: piIds.map((piId, idx) => ({
          label: `Humidity - ${piId}`,
          data: humChart_data.dataByPi[piId],
          borderColor: colors[idx % colors.length],
          tension: 0.2,
          spanGaps: true
        }))
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: "Time" },
            ticks: {
              maxRotation: 45,
              minRotation: 45,
              autoSkip: true,
              maxTicksLimit: 10,
              callback: function(value) {
                const timestamp = this.getLabelForValue(value);
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-NZ', {
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                });
              }
            }
          },
          y: { title: { display: true, text: "Humidity (%)" } }
        },
        plugins: {
          legend: { position: "top" },
          tooltip: {
            callbacks: {
              title: (ctx) => {
                const date = new Date(ctx[0].label);
                return date.toLocaleString('en-NZ');
              },
              label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}%`
            }
          }
        }
      }
    });
  } catch (e) {
    console.error("Error in updateCharts:", e);
  }
}

    
    // Function for downsampling to reduce amount of data points on graph
    function downsample(data, maxPoints = 200) {
      if (data.length <= maxPoints) return data;
      const step = Math.ceil(data.length / maxPoints);
      return data.filter((_, i) => i % step === 0);
    }
    
    // Listen for time window changes
    document.getElementById("timeWindow").addEventListener("change", () => {
      console.log("Time window changed");
      updateDisplay();
    });

    // Polling intervals
    fetchLive();
    setInterval(fetchLive, 2000);

    fetchHistory();
    setInterval(fetchHistory, 60000);
  </script>
</body>
</html>
